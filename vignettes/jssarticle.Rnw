\documentclass[article,nojss]{jss}

\usepackage{times} 
\usepackage{amsmath,amssymb,amsfonts,textcomp} 
\usepackage{graphicx}
\usepackage{epstopdf}
\usepackage{cite}
\usepackage{url}
\usepackage{listings}  
\usepackage{Sweave}
\usepackage{color}
\usepackage{stfloats}
\usepackage{setspace}
\usepackage{tikz}
\usepackage{array}
\usepackage{multirow}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{soul}
\definecolor{upforestgreen}{rgb}{0.0, 0.27, 0.13}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
%\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{algorithm}
\usepackage{algorithmic}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\renewcommand{\algorithmicrequire}{\textbf{Input: }}
\renewcommand{\algorithmicensure}{\textbf{Initialize: }}
\SweaveOpts{concordance=TRUE}

%\VignetteIndexEntry{Distance Measures for Time Series in R: the TSdist Package}
%\VignetteDepends{TSdist,zoo,xts,proxy}
%\VignetteKeywords{timeseries, distance}
%\VignettePackage{TSdist}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\author{Usue Mori\\  University of the \\ Basque Country \\ UPV/EHU. \And 
        Alexander Mendiburu \\ University of the \\ Basque Country  \\ UPV/EHU. \And Jose A. Lozano \\ University of the \\ Basque Country \\ UPV/EHU.}
\title{Distance Measures for Time Series in R: the TSdist Package}


\Plainauthor{Usue Mori, Alexander Mendiburu, Jose A. Lozano} 
\Plaintitle{Distance Measures for Time Series in R: the TSdist Package}  
\Shorttitle{\pkg{TSdist}: Distance Measures for Time Series} 


\Abstract{
 The definition of a distance measure between time series is critical for many time series data mining tasks such as clustering and classification. For this reason, and based on the specific characteristics of time series data, a vast number of distance measures have been published in the past few years. However, many of the most popular distance measures for time series are not included in any \proglang{R} package.  With the objective of filling this gap, a complete set of the most popular distance measures for time series are implemented in the \pkg{TSdist} \code{R} package . This package is designed to work with different time series data types supported in \proglang{R} such as \code{ts}, \code{xts} or \code{zoo}, as well as with numeric vectors. Furthermore, the efficient calculation of distance matrices for entire databases is supported in the package. 
 
}
\Keywords{time series, distance measures, \proglang{R}}
\Plainkeywords{} 

\Address{
  Usue Mori, Jose A. Lozano\\
  Intelligent Systems Group (ISG) \\ Department of Computer Science and Artificial Intelligence \\ University of the Basque Country UPV/EHU \\ Manuel de Lardizabal 1 \\ 20018 Donostia-San Sebastian, Spain. \\
  E-mail: \email{usue.mori@ehu.es, ja.lozano@ehu.es}\\\\
  
   Alexander Mendiburu\\
  Intelligent Systems Group (ISG) \\ Department of Computer Architecture and Technology \\ University of the Basque Country UPV/EHU \\ Manuel de Lardizabal 1 \\ 20018 Donostia-San Sebastian, Spain. \\
  E-mail: \email{alexander.mendiburu@ehu.es}\\
}


%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}


\section[intro]{Introduction}

In recent years, the increase in data collecting technologies and sensors has enabled access to a large amount of temporal data, also denominated time series. The main characteristics of this type of data are its high dimensionality, dynamism, auto-correlation and noisy nature, all which complicate the study and pattern extraction to a large extent. In view of this, many researchers have focused on finding specific methods  and on adapting the existing data mining algorithms to obtain useful information from these databases. So, tasks such as regression, classification, clustering or segmentation have been extended and modified successfully \citep{Fu2011}. 

Many of these tasks require the definition of a distance measure which will indicate the level of similarity or dissimilarity between time series. Because of this, the scientific community has focused on elaborating suitable measures for this specific type of data. The fruit of this work, a vast portfolio of distance measures, has been published.

A few \proglang{R} packages such as \pkg{dtw} \citep{ToniGiorgino2009} or \pkg{TSClust} \citep{Montero2014} provide implementations of some of these distance measures. However, to the extent of our knowledge, many of the most popular distances reviewed by \citet{WarrenLiao2005, Esling2012, Wang2012} are not available in \proglang{R}.

In this paper, the \pkg{TSdist} package for the R statistical software \citep{Team2014} is presented. This package provides the implementation of a set of distance measures designed for univariate numerical time series. These distance measures have been selected based on their popularity and because they are mentioned in recent reviews on the topic \citep{WarrenLiao2005, Esling2012, Wang2012}. In this manner, this package largely contributes to achieving a more complete coverage of the published time series distance measures in \proglang{R}.

The rest of the paper is organized as follows. In Section~\ref{similarity}, the distance measures included in the package are described and the details concerning their implementation and computation are summarized. Furthermore, some examples of their use are included. In Section~\ref{wrapper}, the distance computation between objects of type \code{ts}, \code{zoo} or \code{xts} is explained. In Section~\ref{matrices} the calculation of distance matrices of entire time series databases by means of the \pkg{TSdist} package is studied. To finish, in the last section, a summary of the distance measures implemented in the different \proglang{R} packages is given, providing a complete view of the possibilities for time series distance computation in this language.

\section[similarity]{Definition of similarity measures}\label{similarity}

In this section, the distance measures implemented in the \pkg{TSdist} package are described and the functions included for their calculation are detailed. 

These basic distance function will be designed to work only with numeric vectors. To calculate distances between time series objects of type \code{zoo}, \code{xts} or \code{ts} (see Section~\ref{wrapper}).

Following the categorization introduced by \citet{Esling2012}, the time series distance measures are usually divided into four categories: shape based, edit based, features based and structure based. This package focuses on the first three categories because they are applicable to all cases.

\subsection{Shape based distance measures}

This first category of distances is based on directly comparing the raw values and the shape of the series in different manners.

\subsubsection{$L_p$ distances}

$L_p$ distances are those that derive from the different $L_p$ norms \citep{Yi2000}. These distances are rigid metrics that can only compare series of the same length. However, due to their simplicity, they have been widely used in many tasks related to time series analysis and mining.   Given two time series $X=\{x_0,x_1,...,x_{N-1}\}$ and $Y=\{y_0,y_1,...,y_{N-1}\}$, the different variations of the $L_p$ distances and their formulas are provided in Table~\ref{Lp}. It must be noted that the Euclidean Distance is a special case of the Minkowski distance, but it is explicitly included because it is a baseline distance measure in the area of time series data mining.

These distances are implemented in the \code{manhattanDistance()}, \code{minkowskiDistance()}, \code{euclideanDistance()} and \code{infinitenormDistance()} functions. They receive two time series, represented by numeric vectors as the only input, except the Minkowski distance which also needs a specification of \code{p}. The output of these functions is the distance between the two series.
{\doublespacing
\begin{table}[h]
\begin{center}
\small
\begin{tabular}{C{4cm}  C{4cm}  C{4cm}}  
\textbf{Distance}       &  \textbf{p} & \textbf{Formula}   \\ [1ex] \hline \\ [-1.5ex]
Manhattan    & $p=1$ &  $\sum_{i=0}^{N-1} {|x_i-y_i|}$  \\ [1ex]  \hline  \\ [-1.5ex]
Minkowski     & $1<p<\inf$ &  $\sqrt[p]{\sum_{i=0}^{N-1} {(x_i-y_i)^{\frac{1}{p}}}}$  \\ [1ex] \hline  \\ [-1.5ex]
Euclidean     & $p=2 $ &  $\sqrt{\sum_{i=0}^{N-1} {(x_i-y_i)^2}}$  \\ [1ex] \hline \\ [-1.5ex]
Infinite norm    & $p=\inf$ &  $\operatorname*{max}_{i=0,...,N-1}{|x_i-y_i|}$  \\ [1ex] \hline  \\ [-1.5ex]
\end{tabular}
\caption{\small{$L_p$ distances}}
\label{Lp}
\end{center}
\end{table}}
A wrapper function, \code{lpDistances()}, has also been defined for the $L_p$ distances. This function also takes two numeric vectors as input but, in addition, the \code{method} argument must be set to the desired $L_p$ distance measure (e.g \code{method = "euclidean"}). In the case of the Minkowski distance, the argument \code{p} must also be specified.

\subsubsection{Short Time Series distance}

The Short Time Series distance (STS) is introduced by \citet{Moller-Levet2003} with the idea of proposing a distance adapted to the characteristics of irregularly sampled series. It is defined as: 
%
{\small
\begin{equation}
d_{STS}(X,Y)=\sqrt{\sum_{k=0}^{N-1} \left(\frac{y_{k+1}-y_k}{t_{k+1}-t_{k}}- \frac{x_{k+1}-x_{k}}{t'_{k+1}-t'_{k}}\right)}
\end{equation}}
%
{\noindent where $t$ and $t'$ are the temporal indexes of series $X$ and $Y$ respectively.}

This distance can be calculated by invoking the \code{stsDistance()} function and specifying four numeric vectors that represent the two series \code{x} and \code{y} and their temporal indexes \code{t} and \code{t'}. \code{x} and \code{y} must have the same length and, although their temporal indexes may start in different time contexts, the increments must be equal: 
%
{\small
\begin{equation}
t_{k+1}-t_k=t'_{k+1}-t'_k, \, \, \, \forall k=0,...,N-1
\end{equation}}
%
Furthermore, if the temporal indexes are not specified, a constant sampling rate will be assumed. 


\subsubsection{Dissim Distance}

The Dissim distance was introduced by \citep{Frentzos2007} and is specifically designed for series collected at different sampling rates. This means that each series will be defined in a finite set of time instants, but these can be different for each series (see Figure~\ref{fig:dissim}).

\begin{figure}[h]
\centering
\includegraphics[trim = 0mm 0mm 0mm 0mm, clip=TRUE, width=0.4\textwidth]{dissim.pdf}
\caption{Representation of the Dissim distance calculation.}
        \label{fig:dissim}
\end{figure}
%
The Dissim distance requires a continuous representation of the series and so, the series that are being compared are assumed to be linear between sampling points (see Figure~\ref{fig:dissim}). Once this is done, the idea is to calculate the definite integral of the Euclidean distance between them:
%
{\small
\begin{equation} \label{eq:dissim}
Dissim(X,Y)=\sum_{i=0}^{K-1} \int_{t_i}^{t_{i+1}}D_{X,Y}(t) dt
\end{equation}}
%
where, $T=\{t_0,...,t_{K-1}\}$ is a global time index that fuses the time indexes of both series by taking all the points that appear in both sets. $D_{X,Y}(t)$ represents the Euclidean distance between the series at time-stamp $t$. 

This distance measure is implemented in the \code{dissimDistance()} function that takes the two numeric series (\code{x} and \code{y}) and their corresponding temporal indexes (\code{tx} and \code{ty}) as input. It must be noted that, although these indexes may differ, they must start and end at the same instants of time.

Finally, in order to avoid the computational expense of calculating the integral, \citet{Frentzos2007} present an approximation of Dissim that simplifies Equation~\ref{eq:dissim} by using the trapezoid rule. In this manner, the following simpler formula is obtained: 
%
{\small
\begin{equation} 
Dissim\text{\_}approx(X,Y) = \sum_{i=0}^{N-1} (D_{X,Y}(t_i)+D_{X,Y}(t_{i+1})) \cdot (t_{i+1}-t_i)
\end{equation}}
%
This approximation may be calculated by invoking the \code{dissimapproxDistance()} function, which is defined with the same input arguments as in the previous case.

\subsubsection{Dynamic Time Warping distance (DTW)}

In order to overcome the inconveniences of rigid distances such as Euclidean Distance, many similarity measures have been specifically designed for time series data. Among them the most popular is probably Dynamic Time Warping (DTW) \citep{Berndt1994}. 

\begin{figure}[h]
\centering
\begin{tikzpicture}
\node[above right] (img) at (0,0) {\includegraphics[width=0.45\textwidth]{DTW2.pdf}};
\node at (230pt,130pt) {$d(x_i,y_j)$};
\node at (56pt,-1pt) {\footnotesize{$0$}};
\node at (197pt,-1pt) {\footnotesize{$N-1$}};
\node[rotate=90] at (46pt,50pt) {\footnotesize{$0$}};
\node[rotate=90] at (46pt,190pt) {\footnotesize{$M-1$}};
\node[text=blue] at (125pt,32pt) {\large{$\mathbf{X}$}};
\node[text=upforestgreen,rotate=90] at (7pt,115pt) {\large{$\mathbf{Y}$}};
\draw[thick,->] (7.3,4.5) -- (5.2,3.4);
\end{tikzpicture}
        \caption{Illustration of the Dynamic Time Warping distance calculation}
        \label{fig:dtw}
\end{figure}

As shown in Figure~\ref{fig:dtw}, the objective of this distance is to find the optimal alignment between two series $X=\{x_0,x_1,...,x_{N-1}\}$ and $Y=\{y_0,y_1,...,y_{M-1}\}$, by searching for the minimal path in a distance matrix ($D$) that defines a mapping between them.  Each entry of the matrix $D$ is defined by the Euclidean distance between a pair of points $(x_i, y_j)$. In \proglang{R}, the calculation of $D$ is efficiently done by using the \pkg{proxy} package \citep{Meyer2013}.

This optimization problem is subject to three restrictions \citep{WarrenLiao2005}. The \emph{boundary condition} forces the path to start in position $D(0,0)$ and to end 
in $D(N-1,M-1)$. The \emph{continuity condition} restricts the step size, forcing the path to continue through one of the adjacent cells. Finally, 
the \emph{monotonicity condition} forbids the path to move backwards in the positions of the matrix. Based on this, the problem is reduced to solving the following recurrence:
%
{\small
\begin{equation}\label{eq:edr}
DTW(X,Y) = \left\{
\begin{array}{c l}
 0 & \text{if} \,\, M-1=N-1=0\\
\inf & \text{if} \,\, M-1=0 \,\, \text{or} \,\, N-1=0\\
d(x_0,y_0)+min\{DTW(Rest(X),Rest(Y)),\\ DTW(Rest(X),Y), DTW(X, Rest(Y))\} & \text{otherwise}
\end{array}
\right.
\end{equation}
}
%
{\noindent where $d$ is the Euclidean distance and, being $X=\{x_0,x_1,...,x_{N-1}\}$ and $Y=\{y_0,y_1,...,y_{M-1}\}$,  $Rest(X)$ and $Rest(Y)$ are defined as $\{x_1,...,x_{N-1}\}$ and $\{y_1,...,\allowbreak y_{M-1}\}$. }

Based on its definition, this distance is able to deal with transformations such as local warping and shifting and, furthermore, it allows the comparison between series of different length.

By applying dynamic programming, this recurrence can be solved as shown in Algorithm~\ref{DTWal}.

\small{
\begin{algorithm}
\caption{Dynamic Time Warping calculation}
\label{DTWal}
\begin{algorithmic}
\REQUIRE $X=\{x_0,...,x_{N-1}\}, Y=\{y_0,...,y_{M-1}\}$
\ENSURE{$costMatrix=matrix(N+1,M+1)*0$}

\FOR{$i=1,...,N$}
\STATE{ $costMatrix(i,0)=10000$}
\ENDFOR

 \FOR{$j=1,...,M$}
 \STATE{$costMatrix(0,j)=10000$}
 \ENDFOR
 
 \FOR{$i=1,...,N$}
  \FOR{$j=1,...,M$}
 \STATE {$costMatrix(i,j)=d(x_i,y_j)+min \left\{
\begin{array}{l}
costMatrix(i-1,j) \\
costMatrix(i,j-1)\\
costMatrix(i-1,j-1) 
\end{array}
\right. $}
 \ENDFOR
  \ENDFOR
  \RETURN{$costmatrix(N,M)$}
\end{algorithmic}
\end{algorithm}
}

\normalsize

 The calculation of this basic DTW distance is implemented in the \code{dtwDistance()} function. The core of this function has been implemented in \proglang{C}, due to computational efficiency issues. The output of the function is the DTW distance between the two series.

Additionally, it must be noted that it is quite common to add an extra temporal constraint to DTW by limiting the number of vertical or horizontal steps that the path can take consecutively. The windowing type implemented in this package is the classical Sakoe-Chiba band \citep{sakoe_dynamic_1978} which places a symmetric band around the main diagonal and forces the path to stay inside this band (see Figure~\ref{fig:window}). 

\begin{figure}[h]
\centering
\begin{tikzpicture}
\node[above right] (img) at (0,0) {\includegraphics[width=0.45\textwidth]{DTW.pdf}};
\node at (230pt,130pt) {$d(x_i,y_j)$};
\node at (56pt,-1pt) {\footnotesize{$0$}};
\node at (197pt,-1pt) {\footnotesize{$N-1$}};
\node[rotate=90] at (46pt,50pt) {\footnotesize{$0$}};
\node[rotate=90] at (46pt,190pt) {\footnotesize{$M-1$}};
\node[text=blue] at (125pt,32pt) {\large{$\mathbf{X}$}};
\node[text=upforestgreen,rotate=90] at (7pt,115pt) {\large{$\mathbf{Y}$}};
\draw[thick,->] (7.3,4.5) -- (4.7,3.5);
\end{tikzpicture}
        \caption{Illustration of the Sakoe-Chiba windowing applied to the Dynamic Time Warping distance calculation.}
        \label{fig:window}
\end{figure}

This adjustment avoids the matching of points that are very far from each other in time and, in addition, it reduces the computation cost \citep{Wang2012}.

If we want to restrict the window size in the DTW calculation, an additional argument \code{sigma} must be added to the \code{dtwDistance()} function invocation. This argument represents the window size and must be a positive integer value. The window size can not exceed the length of the series and in addition, the function will return an error message if $|length(X)-length(Y)|>$\code{sigma}, because in this case the boundary condition can not be fulfilled and no possible warping solution will exist.

\subsubsection{LB-Keogh for Dynamic Time Warping}

Calculating the Dynamic Time Warping between a pair of series is computationally quite expensive and, because of this, many lower bounds have been introduced in the literature for this distance. These lower bounds are essentially approximations of the DTW distance that provide a  value which is always lower than the actual DTW measure. They are computationally more efficient than DTW and become especially useful for the task of similar series retrieval, because they allow the pruning of sequences that are largely dissimilar to the query series. One of the most common of such lower bounds is that introduced by \citet{Keogh2004}. 

Given a query series $X$ and a reference series $Y$, the first step in the calculation of this lower bound is obtaining an upper and lower envelope series for the query series. Given an allowed range of warping $r$, the upper and lower envelope series are defined as follows: 
%
{\small
\begin{eqnarray}
U_i=max(X_i-r, X_i+r)\\
L_i=min(X_i-r, X_i+r)
\end{eqnarray}}
%
where $r$ can take a fixed value or it can be a function of $i$, depending on the windowing function used. In this case, the Sakoe-Chiba band \citep{sakoe_dynamic_1978} will be used to calculate the envelopes, so $r$ will take a constant value indicating the width of the window.

Once the upper and lower envelopes have been calculated, the lower bounding distance between $X$ and $Y$ is calculated by using the following formula: 
%
{\small
\begin{equation}
LB\_Keogh(X,Y) = \left\{
\begin{array}{c l}
 (Y_i-U_i)^2 & \text{if} \, \, \, \,  Y_i > U_i\\
 (Y_i-L_i)^2 & \text{if} \, \, \, \,  Y_i < L_i\\
 0 & \text{otherwise}
\end{array}
\right.
\end{equation}}
%
This lower bound is implemented in the \code{lbKeoghDistance()} function that takes a numeric vector that represents the query series \code{x}, a numeric series that defines the reference series \code{y} and a window size \code{sigma} as input arguments and returns the Keogh lower bound for the DTW distance.

\subsection{Edit based distances}

Edit distance  was initially presented to calculate the similarity between two sequences of strings and is based on the idea of counting the minimum number of edit operations (delete, insert and replace) that are necessary to transform one sequence into the other. 

The problem of working with real numbers is that it is difficult to find exact matching points in two different sequences and, therefore, the edit distance is not directly applicable. Different adaptations have been proposed in the literature and those included in the \pkg{TSdist} package are the most common according to recent reviews \citet{Wang2012, Esling2012}.

By using the delete and insert operations, all these distances are able to work with series of different length.

\subsubsection{Edit Distance for Real Sequences (EDR)}

In this first edit based distance, in order to adapt it to numerical values, the distance between the points in the time series is reduced to 0 or 1 \citep{Chen2005}. If two points $x_i$ and $y_j$ are closer to each other in the absolute sense than a user specified $\epsilon$, they will be considered equal. On the contrary, if they are farther apart, they will be considered distinct and the distance between them will be 
considered 1. In \proglang{R}, this initial mapping between two series is efficiently done by using the \pkg{proxy} package and applying vector operations to the resulting matrix.  

As an additional property, EDR permits gaps or unmatched regions in the database but it penalizes them with a value equal to their length. All this summarizes into the following recursion that is converted into an iteration by means of dynamic programming as in the previous case:
%
{\small
\begin{equation}
EDR(X,Y) = \left\{
\begin{array}{c l}
 N & \text{if} \,\, M-1=0\\
M & \text{if} \,\, N-1=0 \\
min\{EDR(Rest(X),Rest(Y)) + d_{edr}(x_0,y_0), \\ EDR(Rest(X),Y) + 1, EDR(X, Rest(Y)) +1 \} & \text{otherwise}
\end{array}
\right.
\end{equation}
}
%
{\noindent where $d_{edr}$ represents the distance between two points in the series and takes a value of 0 or 1, as explained above.}

  The value of this distance measure can be calculated by means of the \code{edrDistance()} function, which takes two numeric vectors and a threshold parameter \code{epsilon} as input. 
  
  Finally, as with DTW, a Sakoe-Chiba windowing may be added to the EDR distance by simply adding a positive integer  \code{sigma} value to the function call.

\subsubsection{Longest Common Subsequence distance (LCSS)}

The second edit based distance included in the \pkg{TSdist} package, which is in fact a similarity measure, is the \textbf{Longest Common Subsequence  distance (LCSS)} \citep{Vlachos}. In this case, the similarity between two time series is quantified in terms of the longest common sub-sequence but, taking into account that  gaps or unmatched regions are permitted.

As with EDR, the initial mapping between the series is done with the aid of the \pkg{proxy} package and the Euclidean distance. Then, the distance between two points is reduced to 0 or 1 depending on a threshold $\epsilon$. All this is reduced to the following recurrence:
%
{\small
\begin{equation}
LCSS(X,Y) = \left\{
\begin{array}{c l}
 0 & \text{if} \,\, M-1=0 \, \, \text{or} \, \, N-1=0 \\
 LCSS(Rest(X),Rest(Y))+1 & \text{if} \,\, |x_0-y_0| \leq \epsilon \\
max\{LCSS(Rest(X),Y), LCSS(X, Rest(Y)) \} & \text{otherwise}
\end{array}
\right.
\end{equation}
}
%
This recurrence is usually solved by using dynamic programming, similar to the two previous distance measures and is implemented in the \code{lcssDistance()} function. The input arguments to this function are two numerical vectors \code{x} and \code{y}, a threshold parameter \code{epsilon} and an optional \code{sigma} value that will be added if a temporal constraint is desired. As with the other distances, the function will return the distance value between the two series (\code{d}).

\subsubsection{Edit Distance with Real Penalty (ERP)}

The third adaptation to the edit distance is \textbf{Edit Distance with Real Penalty (EDR)} \citep{Chen2004} which is a combination of DTW and EDR. 

In this case, given two time series $X=\{x_0,x_1,...,x_{N-1}\}$ and $Y=\{y_0,y_1,...,y_{M-1}\}$, the initial mapping is done by using the Euclidean distance and the \pkg{proxy} package as with DTW. The similarity with EDR relies on the fact that gaps are permitted. However, penalization will be carried out differently, by setting  a user specified constant $g$ and adding the euclidean distance ($d$) of the unmatched points to this constant.
%
{\footnotesize
\begin{equation}
ERP(X,Y) = \left\{
\begin{array}{c l}
 \sum_{i=0}^{N-1} |y_i-g| & \text{if} \,\, M-1=0\\
 \sum_{i=0}^{M-1} |x_i-g| & \text{if} \,\, N-1=0\\
min\{ERP(Rest(X),Rest(Y)) + d(x_0,y_0), \\ ERP(Rest(X),Y) + d(x_0,g), ERP(X, Rest(Y)) + d(g,y_0) \} & \text{otherwise}
\end{array}
\right.
\end{equation}
}
%
The \code{R} function that calculates this distance  is \code{erpDistance()} and in order to invoke it, two numeric vectors and a user defined \code{g} parameter must be provided necessarily as input. In addition, a Sakoe-Chiba temporal constraint can be added to the calculation if the \code{sigma} argument is added to the call.

\subsection{Feature based distances}

This category of distance measures focuses on extracting a set of features from the time series and calculating the similarity between these features instead of using the raw values of the series.

\subsubsection{Distances based on Pearson's correlation}

Pearson's correlation between two time series $X=\{x_0,x_1,...,x_{N-1}\}$ and $Y=\{y_0,y_1,...,y_{N-1}\}$ is defined as: 
%
{\small
\begin{equation}\label{eq:correlation}
PC(X,Y)=\frac{\sum \limits_{i=0}^{N-1}{(x_i-\bar{x})(y_{i}-\bar{y})}}{\sqrt{(x_i-\bar{x})^2}\sqrt{(y_{i}-\bar{y})^2}}
 \end{equation}}
%
where $\bar{x}$ and $\bar{y}$ are the mean values of the series.

Based on this value, two distance measures were introduced by \citet{Golay1998}: 
%
{\small
\begin{equation}
d_{PC1}(X,Y)=\left(\frac{1-PC}{1+PC}\right)^\beta
\end{equation}}
%
{\small
\begin{equation}
d_{PC2}(X,Y)=2(1-PC)
\end{equation}}
%
where $\beta$ is a positive parameter defined by the user.

These two distance measures are implemented in the \code{correlationDistance()} function. If the \code{beta} parameter is specified, the first distance will be calculated and if not, then, the second definition will be applied. Other than that, the function takes two numeric vectors \code{x} and \code{y} as input and returns the distance between them (\code{d}).

\subsubsection{Distance based on the cross-correlation}

This distance is presented in \citep{WarrenLiao2005} and is based on the cross-correlation between two series. The cross-correlation between two series at lag $k$ is calculated as:
%
{\small
\begin{equation}\label{eq:correlation}
CC_{k}(X,Y)=\frac{\sum \limits_{i=0}^{N-1-k}{(x_i-\bar{x})(y_{i+k}-\bar{y})}}{\sqrt{(x_i-\bar{x})^2}\sqrt{(y_{i+k}-\bar{y})^2}}
 \end{equation}
}
%
where $\bar{x}$ and $\bar{y}$ are the mean values of the series as in the previous case. Based on this, the distance measure is defined as: 
%
{\small
\begin{equation}
d_{CC}(X,Y)=\sqrt{\frac{(1-CC_{0}(X,Y))}{\sum_{k=1}^{max} CC_{k}(X,Y)}}
\end{equation}}
%
This distance measure can be calculated by using the \code{crosscorrelationDistance()} function included in the \pkg{TSdist} package and specifying two numeric vectors (\code{x} and \code{y}) and a value for \code{max}. This last argument represents the maximum lag that is considered in the calculation and should not exceed the length of the series. As in the other cases, this function will return the distance between the two series.

\subsubsection{Fourier Coefficients based distance}

As its name indicates, the similarity calculation in this case is based on comparing the 
Discrete Fourier Transform coefficients of the series. 

Given a numeric series $X=\{x_0,x_1,...,x_{N-1}\}$, its Discrete Fourier Transform can be easily calculated in \proglang{R} by using the \code{fft()} function included in the \pkg{stats} package. This function simply returns an array containing the Fourier Coefficients of the series. The value of each coefficient measures the contribution of its associated frequency to the series and, based on this, 
the Inverse Fourier Transform provides the means to represent the sequences as a combination of sinusoidal forms. 

It is important to note that the Fourier coefficients are complex numbers that can be expressed as $X_f=a_f+b_fi$. In the case of real sequences 
such as time series, the Discrete Fourier Transform is symmetric and therefore it is sufficient to study the first $\frac{N}{2}+1$ coefficients. Furthermore, it is commonly considered that, for many time series, most of the information is kept in their first $n$ Fourier Coefficients, where $n<\frac{N}{2}+1$ \citep{Agrawal1993}.

Based on all this information, the distance between two time series $X$ and $Y$ with Fourier Coefficients 
$\{(a_0,b_0), \allowbreak...,(a_{\frac{N}{2}},b_{\frac{N}{2}})\}$ and  $\{(a'_0,b'_0),...,(a'_{\frac{N}{2}},b'_{\frac{N}{2}})\}$ is given by the Euclidean distance between the first $n$ coefficients: 
{\small
\begin{equation}
F(X,Y)=\sqrt{\sum_{i=0}^{n} \left ( (a_i-a'_i)^2+(b_i-b'_i)^2 \right)}
\end{equation}}
%
This distance is implemented in the \code{fourierDistance()} function and apart from two numeric series, the number of parameters to be considered (\code{n}) must be specified.

\subsubsection{TQuest distance}

TQuest was presented by \citet{Abfalg2006} and is classified as a feature based distance in \citep{Esling2012}. In this manner, instead of comparing the raw values of the series, it studies the similarity of a set of features extracted from them. 
%
\begin{figure}[h!]
\centering
\begin{tikzpicture}
\node[above right] (img) at (0,0) {\includegraphics[width=0.43\textwidth]{TQuest.pdf}};
\node at (25pt,5pt) {\footnotesize{$t_1$}};
\node at (34pt,5pt) {\footnotesize{$t_2$}};
\node at (78pt,5pt) {\footnotesize{$t_3$}};
\node at (85pt,5pt) {\footnotesize{$t_4$}};
\node at (93pt,5pt) {\footnotesize{$t_5$}};
\node at (100pt,5pt) {\footnotesize{$t_6$}};
\node at (127pt,5pt) {\footnotesize{$t_7$}};
\node at (170pt,5pt) {\footnotesize{$t_8$}};
\node at (178pt,5pt) {\footnotesize{$t_9$}};
\node at (187pt,5pt) {\footnotesize{$t_{10}$}};
\node[text=red] at (4pt,120pt) {\huge{$\mathbf{\tau}$}};
\node at (106pt,-15pt) {$S(X,\tau)=\{(t_1,t_2),(t_3,t_4),(t_5,t_6),(t_7,t_8), (t_9,t_{10})\}$};
\end{tikzpicture}
        \caption{Time series representation method used by the TQuest distance.}
        \label{fig:tquest}
\end{figure}
%
As can be seen in Figure~\ref{fig:tquest}, the idea is to define the set of time intervals in a time series that fulfill the following conditions: 
%
\begin{enumerate}
 \item  All the values that the time series takes during these time intervals must be strictly above a user specified threshold $\tau$.
 \item They are the largest possible intervals that satisfy the previous condition.
\end{enumerate}
%
The distance between two time series $X$ and $Y$ that are represented by the interval sets $S(X,\tau)$ and $S(Y,\tau)$ is defined as follows: 
%
{\small
\begin{equation}
 TQuest(X,Y)=\frac{1}{|S(X,\tau)|} \sum_{s \in S(X,\tau)} \min_{t \in S(Y,\tau)} d(s,s') + \frac{1}{|S(Y,\tau)|} \sum_{s' \in S(Y,\tau)} \min_{s \in S(X,\tau)} d(s',s)
\end{equation}
}
%
{\noindent where the distance between two intervals $s=(s_l,s_u)$ and $s'=(s'_l,s'_u)$  is calculated as:}
{\small
\begin{equation}
d(s,s')=\sqrt{(s_l-s'_l)^2+(s_u-s'_u)^2}
\end{equation}}
%
This distance is implemented in the \code{tquestDistance()} function and relies on the potential of \proglang{R} for working with vectors to find the threshold passing points and to define the threshold passing intervals. The input values of the function are two numeric series, \code{x} and \code{y}, their temporal indices \code{tx} and \code{ty} and a threshold \code{tau}. It provides the TQuest distance between the two series.

\subsection{Examples of distance calculations between numeric vectors}

The \code{example.series1} and \code{example.series2} objects included in the \pkg{TSdist} package are two numeric vectors that represent two different synthetic series which are generated based on the shapes that define the Two Patterns synthetic database of series \citep{Geurts2002} (See Figure~\ref{example12}).

\begin{figure}[h]
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
                \centering
                \includegraphics[width=\textwidth]{exampleseries1.pdf}
                \caption{\small{example.series1}}
                \label{fig:warp}
        \end{subfigure}%
       \quad \hspace{0.5cm}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \centering
                 \includegraphics[width=\textwidth]{exampleseries2.pdf}
                \caption{\small{example.series2}}
                \label{cds}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
 
        \caption{\small{The two example series of the same length included in the TSdist package.}}\label{example12}
\end{figure}

Additionaly, \code{example.series3} and \code{example.series4} represent two ARMA(3,2) series of coefficients AR=(1, -0.24, 0.1) and MA=(1, 1.2) but with different lengths, 100 and 120, and generated with different random seeds (See Figure~\ref{example34}). 

\begin{figure}[h]
        \centering
        \begin{subfigure}[b]{0.3\textwidth}
                \centering
                \includegraphics[width=\textwidth]{exampleseries3.pdf}
                \caption{\small{example.series3}}
                \label{fig:warp}
        \end{subfigure}%
       \quad \hspace{0.5cm}
        \begin{subfigure}[b]{0.3\textwidth}
                \centering
                 \includegraphics[width=\textwidth]{exampleseries4.pdf}
                \caption{\small{example.series4}}
                \label{}
        \end{subfigure}
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
          %(or a blank line to force the subfigure onto a new line)
 
        \caption{\small{The two example series of different length included in the TSdist package.}}\label{example34}
\end{figure}

\newpage

\textbf{Example 1}  \hspace{0.2cm}  \emph{The basic calculation of the distance between two series such as \code{example.series1} and \code{example.series2} is done as follows:}

<<echo=FALSE>>=
library("TSdist")
data(example.series1)
data(example.series2)
@
<<echo=TRUE>>=
crossCorrelationDistance(example.series1, example.series2)
correlationDistance(example.series1, example.series2)
@
\vspace{0.5cm}

\textbf{Example 2}  \hspace{0.2cm} \emph{A special case are the $L_p$ distances that can also be called by the wrapper function \code{lpDistance}:}



<<echo=TRUE>>=
manhattanDistance(example.series1, example.series2)
@

\noindent{\emph{is equivalent to: }}
<<echo=TRUE>>=
lpDistance(example.series1, example.series2, method="manhattan")
@

\vspace{0.5cm}

\textbf{Example 3} \hspace{0.2cm} \emph{Many of the distance measures require the definition of a parameter, which must be included in the call to the corresponding function:}



<<echo=TRUE>>=
edrDistance(example.series1, example.series2, epsilon=0.1)
erpDistance(example.series1, example.series2, g=0)
@

\vspace{0.5cm}

\textbf{Example 4} \hspace{0.2cm} \emph{Some measures are able to compute the distance between series of different lengths but others are not and will return an error in this case:}


<<echo=FALSE>>=
data(example.series3)
data(example.series4)
@
<<echo=TRUE>>=
 lcssDistance(example.series3, example.series4, epsilon=0.1)
@
\begin{Schunk}
\begin{Sinput}
> fourierDistance(example.series3, example.series4)
\end{Sinput}
\begin{Soutput}
Error : The length of the series must be equal
\end{Soutput}
\end{Schunk}

\vspace{0.5cm}

\textbf{Example 5} \hspace{0.2cm} \emph{Other errors will be specific to each distance measure and will be determined based on their definition. As an example, the window function defined for DTW can not exceed the size of the time series being compared.}


<<echo=TRUE>>=
length(example.series3)
length(example.series4)
@  
\begin{Schunk}
\begin{Sinput}
> dtwDistance(example.series3, example.series4, sigma=105)
\end{Sinput}
\begin{Soutput}
Error : The window size exceeds the length of the first series
\end{Soutput}
\end{Schunk}

{\noindent \emph {Furthermore, the window size must be larger that the difference of the series lengths:}}

\begin{Schunk}
\begin{Sinput}
> dtwDistance(example.series3, example.series4, sigma=10)
\end{Sinput}
\begin{Soutput}
Error : It is not possible to compare those two series 
with the defined window size
\end{Soutput}
\end{Schunk}

\section[wrapper]{The use of time series objects of \proglang{R} in TSdist} \label{wrapper}

Given their relevance and special characteristics, many specific classes or object types have been included in \proglang{R} to define time series. The most common and popular examples are the \code{ts} objects introduced in the basic \pkg{stats} package of \proglang{R} or the more complex \code{zoo} \citep{Zeileis2005} and \code{xts} \citep{Ryan2013} classes implemented in two separate packages. 

All these objects provide the possibility of saving information about the temporal index and, in addition, provide a complete set of methods to work with them. However, there are slight differences between them. The first is the most basic and is addressed exclusively for regularly sampled time series. The \code{zoo} objects incorporate the possibility of dealing with irregularly sampled time series. Finally, the \pkg{xts} package further extends the \pkg{zoo} package to provide a uniform handling of all the time series data types in \proglang{R}.

The \pkg{TSdist} package reviewed in this paper supports the use of these three time series objects by means of the function \code{tsDistances}. This function admits \code{ts} objects or univariate \code{zoo} and \code{xts} objects as well as numeric vectors and works as a wrapper function for all the distances presented in the previous sections. All the input arguments and the results obtained by this function are summarized in Table~\ref{tsDistances}. 

As can be seen, this function simply acts as a link between the time series object types and the functions that calculate the distance measures.


\begin{table}[h]
\begin{center}
\footnotesize
\begin{tabular}{C{1.5cm}  L{5cm}  L{7cm}}  \hline
\textbf{Argument}       &  \textbf{Description} &   \textbf{Remarks}\\ \hline
\code{x}      &      Univariate time series object of type numeric vector, ts, zoo or xts     &             \\ [0.9ex]
\code{y}      &       Univariate time series object of type numeric vector, ts, zoo or xts     &              \\ [0.9ex]
\code{tx}     &      Sampling index of series x (optional)   & Necessary if x is a numeric vector and the sampling is not constant.  \\  [0.9ex]
\code{ty}     &      Sampling index of series y (optional)     & Necessary if y is a numeric vector and the sampling is not constant.  \\  [0.9ex]
\code{method} &      Distance measure     &  \code{"euclidean"}, \code{"manhattan"}, \code{"minkowski"}, \code{"infinitenorm"}, \code{"pearsoncorrelation"},
\code{"crosscorrelation"}, \code{"sts"}, \code{"dtw"}, \code{"keogh_lb"}, \code{"edr"}, \code{"erp"}, \code{"lcss"}, \code{"fourier"}, \code{"tquest"}, \code{"dissim"} or \code{"dissimapprox"} \\  [0.9ex]
...    &     Parameters associated to the selected distance measure    &  \\ [0.9ex]   \hline
\textbf{Result}       &  &   \\ \hline
\code{d}       & Distance between \code{x} and \code{y}. &   \\ \hline
\end{tabular}
\caption{\small{Summary of the function \code{tsDistances}}}
\label{tsDistances}
\end{center}
\end{table}


%
\vspace{-0.5cm}
\subsection{Examples of distance calculations between time series objects}

The \code{zoo.series1} and \code{zoo.series2} time series included in the package are replicas of the \code{example.series1} and \code{example.series2} objects introduced previously but saved in a zoo format with a specific time index. 

\vspace{0.5cm}

\textbf{Example 6} \hspace{0.2cm} \emph{A basic call to the \code{tsDistance} function for two series like these is done in the following manner:}


<<echo=FALSE>>=
data(zoo.series1)
data(zoo.series2)
library(zoo)
library(xts)
@
<<echo=TRUE>>=
tsDistances(zoo.series1, zoo.series2, 
distance="pearsoncorrelation")
tsDistances(zoo.series1, zoo.series2, distance="dtw", sigma=10)
@

The distance calculation between \code{ts} or \code{xts} objects is done in the same manner.

\section[matrices]{Computing distance matrices} \label{matrices}


On some occasions it is necessary to calculate the distance between each pair of series in a given database of series $(X=\{X_1,X_2,...,X_N\})$. This will result in a distance matrix:

$$D(X) =
 \begin{pmatrix}
  d(X_1,X_1) & d(X_1,X_2) & \cdots & d(X_1,X_N) \\
  d(X_2,X_1) & d(X_2,X_2) & \cdots & d(X_2,X_N) \\
  \vdots  & \vdots  & \ddots & \vdots  \\
  d(X_N,X_1) & d(X_N,X_2) & \cdots & d(X_N,X_N) \\
 \end{pmatrix}$$


The \pkg{proxy} package provides the means to calculate pairwise distances between the rows of a given matrix. In view of this, together with loading the \pkg{TSdist} package, the distance measures included in it are loaded into the registry of distances of the \pkg{proxy} package.  With this, distance matrices obtained from the measures included in the \pkg{TSdist} package may be computed directly by simply invoking the \code{dist} method implemented in \pkg{proxy}. The only requirement is that the time series database must be saved in a numeric matrix, where each series is set in a row.

A more direct way of performing this computation is by using the \code{tsDatabaseDistances} function implemented in the package \pkg{TSdist}. The input and output arguments to this function are summarized in Table~\ref{tsMatrixDistances}.

\begin{table}[h]
\begin{center}
\footnotesize
\begin{tabular}{L{1.5cm}  L{6cm}  L{6cm}}  \hline
\textbf{Argument}       &  \textbf{Description} &   \textbf{Remarks}  \\ \hline 
\code{x}     &      Object of type \code{matrix}, \code{list}, \code{mts}, \code{xts} or \code{zoo} that represents a set of series set in a row-wise format .     &             \\ [1.5ex] 
\code{method}   &     Distance measure to be computed.     &  \code{"euclidean"}, \code{"manhattan"}, \code{"minkowski"}, \code{"infinitenorm"}, \code{"pearsoncorrelation"},
\code{"crosscorrelation"}, \code{"sts"}, \code{"dtw"}, \code{"keogh_lb"}, \code{"edr"}, \code{"erp"}, \code{"lcss"}, \code{"fourier"}, \code{"tquest"}, \code{"dissim"} or \code{"dissimapprox"} \\ [1.5ex] 
\code{diag} & Logical value indicating if the diagonal of the distance matrix should be printed. & \\ [2ex]  
\code{upper} & Logical value indicating if the upper triangle of the distance matrix should be printed. & \\  [2ex]  
...    &      Any other parameters associated to the distance measures    &  \\ \hline
\textbf{Result} & & \\ \hline  
\code{D} & Distance matrix of series in \code{x}.  &  An object of the class \code{dist}. \\ \hline
\end{tabular}
\caption{\small{Summary of the function \code{tsDatabaseDistances}}}
\label{tsMatrixDistances}
\end{center}
\end{table}


As can be seen in the table, this function also provides a solution to calculate the pairwise distance between databases saved on \code{list}, \code{mts}, \code{zoo} or \code{xts} objects. It works as a wrapper function and accommodates the structure of this type of objects to the requirements of the \code{dist} function. Note that the series in the database must be of the same length.


The direct distance matrix calculation of databases with series of different sizes or sampling rates are not supported in this package. However, they can be easily obtained by using the \code{tsDistances} combined with \code{for} loops or derivations of the function \code{apply} in \proglang{R}.


\subsection{Examples of distance matrix calculations}

The \code{example.database} object included in the package is a matrix that represents a database with 6 ARMA(3,2) series of coefficients AR=(1, -0.24, 0.1) and MA=(1, 1.2) but with different innovations. The 6 series are set in a matrix in a row-wise format. 

Additionally, the \code{zoo.database} object included in the package is a multivariate \code{zoo} object that saves the series of \code{example.database} but with a specific time index.
\vspace{0.5cm}

\textbf{Example 7} \hspace{0.2cm} \emph{ The \code{dist} function calculates the pairwise distance between all the rows in a matrix, so the calculation of the distance matrix can be done easily for the \code{example.database} object:}


<<echo=FALSE>>=
data(example.database)
library(proxy)
@
<<echo=TRUE>>=
dist(example.database, method="tsDistances", 
distance="tquest", tau=mean(example.database), 
diag=TRUE, upper=TRUE)
@
\vspace{0.5cm}

\noindent {\emph{This can also be calculated by using the \code{tsDatabaseDistances} function:} }


<<echo=FALSE>>=
data(zoo.database)
@
<<echo=TRUE, eval=FALSE>>=
tsDatabaseDistances(example.database, method="tquest", 
tau=mean(example.database), diag=TRUE, upper=TRUE)
@
\vspace{0.5cm}


\textbf{Example 8} \hspace{0.2cm} \emph{The \code{zoo.database} object is not a matrix, so the distance matrix calculation can not be done by using the \code{dist} function directly. In this case, the calculation must be done in the following manner:}

<<echo=TRUE>>=
tsDatabaseDistances(zoo.database, method="tquest", 
tau=mean(zoo.database), diag=TRUE, upper=TRUE)
@



\section[summary]{Summary and comparison of time series distance packages in R}

As commented previously and to the extent of our knowledge, apart from \pkg{TSdist}, two other packages of \proglang{R} provide implementations of distances for time series: \pkg{dtw} and \pkg{TSclust}. 

In Table~\ref{summary}, a summary of the distance measures included in these packages is presented, providing a complete view of the different options available for time series data mining purposes. As can be seen, the three packages focus on different distances and are, therefore, complementary.

\begin{table}[h]
\begin{center}
\footnotesize
\begin{tabular}{L{6.8cm}  C{1.5cm}  C{1.5cm} C{1.5cm}}  
   \textbf{Distance Measure}       &  \pkg{dtw} & \pkg{TSclust}  & \pkg{TSdist} \\ [1ex] \hline \hline 
\textbf{\emph{Shape-based distances}}    &  &  &  \\ \hline  
\hspace{0.3cm}$L_p$ distances   &  &  &  \checkmark \\ \hline 
\hspace{0.3cm}Short Time Series Distance (STS) &  &  & \checkmark \\ \hline
\hspace{0.3cm}Complexity Invariant Time Series Distance  &  & \checkmark &   \\ \hline 
\hspace{0.3cm}DISSIM  &  &  & \checkmark \\ \hline 
\hspace{0.3cm}Approximated DISSIM &  &  & \checkmark \\ \hline 
\hspace{0.3cm}Dynamic Time Warping (DTW)   & \checkmark &  &  \checkmark \\ \hline 
\hspace{0.3cm}Keogh\_LB (DTW)   &  &  &  \checkmark \\ \hline \hline
\textbf{\emph{Edit based distances} }   &  &  &  \\ \hline  
\hspace{0.3cm}Edit Distance for Real Sequences (EDR) &  &  & \checkmark \\ \hline  
\hspace{0.3cm}Edit Distance with Real Penalty (ERP) &  &  & \checkmark \\ \hline  
\hspace{0.3cm}Longest Common Subsequence (LCSS) &  &  & \checkmark \\ \hline  \hline
\textbf{\emph{Feaure-based distances}}    &  &  &  \\ \hline  
\hspace{0.3cm}Autocorrelation and Partial Autocorrelation based &  & \checkmark &  \\ \hline  
\hspace{0.3cm}Pearson correlation based &  & \checkmark &   \checkmark \\ \hline  
\hspace{0.3cm}Cross-correlation based &  &  & \checkmark  \\ \hline  
\hspace{0.3cm}Discrete Fourier Decomposition based &  &  &   \checkmark \\ \hline  
\hspace{0.3cm}Wavelet Decomposition based &  & \checkmark &   \\ \hline  
\hspace{0.3cm}Periodogram based &  & \checkmark &   \\ \hline  
\hspace{0.3cm}SAX based &  & \checkmark &   \\ \hline  
\hspace{0.3cm}Spectral Density based &  & \checkmark &   \\ \hline  
\hspace{0.3cm}TQuest &  &  & \checkmark  \\ \hline  \hline
\emph{Structure-based distances}    &  &  &  \\ \hline  
\hspace{0.3cm}ARIMA model based &  & \checkmark &  \\ \hline  
\hspace{0.3cm}Compression based &  & \checkmark &  \\ \hline  
\hspace{0.3cm} Non Parametric Forecast based &  & \checkmark &  \\ \hline  
\end{tabular}
\caption{\small{Summary of distance measures for time series implemented in \proglang{R}}}
\label{summary}
\end{center}
\end{table}



 The first package, \pkg{dtw}, focuses on a unique distance measure, DTW, and provides an in depth approximation to it, providing many different options and variations of this distance measure. On the contrary, \pkg{TSclust} provides a wide spectrum of simple distance measures, mostly based on the structure of the series or on different features extracted from them. It must be noted that some of these distances are quite ad-hoc and uncommon and are not mentioned in recent reviews \citep{WarrenLiao2005, Esling2012, Wang2012}. Finally, our package \pkg{TSdist} fills the gaps left by these two packages by implementing many of the most common and popular distance measures proposed in the reviews mentioned. Specifically, in addition to adding new measures to the shape-based and feature-based distance categories, edit based distances for numeric time series have been included, which was a completely overlooked category of distance measures in previous \proglang{R} packages.
 
\newpage

\bibliography{library}

\end{document}
